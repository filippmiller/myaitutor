-- Migration: Multi-Pipeline Architecture for AIlingva Tutor
-- Date: 2025-12-07
-- Purpose: Create tables for dual-pipeline (Streaming + Analysis/Brain) system

-- ============================================================
-- 1. tutor_lessons: Enhanced lesson tracking with numbering
-- ============================================================

CREATE TABLE IF NOT EXISTS tutor_lessons (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES user_accounts(id) ON DELETE CASCADE,
    lesson_number INTEGER NOT NULL,
    
    is_first_lesson BOOLEAN DEFAULT FALSE,
    placement_test_run BOOLEAN DEFAULT FALSE,
    placement_level VARCHAR(10),  -- 'A1', 'A2', 'B1', 'B2', 'C1', 'C2'
    
    -- JSON summaries and plans
    summary_json JSONB,
    next_plan_json JSONB,
    pipeline_state_json JSONB,
    
    -- Timestamps
    started_at TIMESTAMP NOT NULL DEFAULT timezone('utc', now()),
    ended_at TIMESTAMP,
    
    -- Link to existing lesson_sessions for backwards compatibility
    legacy_session_id INTEGER REFERENCES lesson_sessions(id),
    
    CONSTRAINT unique_user_lesson_number UNIQUE(user_id, lesson_number)
);

CREATE INDEX idx_tutor_lessons_user_id ON tutor_lessons(user_id);
CREATE INDEX idx_tutor_lessons_lesson_number ON tutor_lessons(user_id, lesson_number);
CREATE INDEX idx_tutor_lessons_started_at ON tutor_lessons(started_at DESC);

COMMENT ON TABLE tutor_lessons IS 'Tracks logical lesson progression per user (1st, 2nd, 3rd...) independent of WebSocket sessions';
COMMENT ON COLUMN tutor_lessons.lesson_number IS '1-indexed lesson counter per user';
COMMENT ON COLUMN tutor_lessons.is_first_lesson IS 'True for the very first lesson (triggers intro + placement test)';
COMMENT ON COLUMN tutor_lessons.placement_level IS 'CEFR level determined during first lesson';
COMMENT ON COLUMN tutor_lessons.legacy_session_id IS 'FK to lesson_sessions for backwards compatibility during migration';

-- ============================================================
-- 2. tutor_lesson_turns: Enhanced turn tracking with pipeline support
-- ============================================================

CREATE TABLE IF NOT EXISTS tutor_lesson_turns (
    id SERIAL PRIMARY KEY,
    lesson_id INTEGER NOT NULL REFERENCES tutor_lessons(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES user_accounts(id) ON DELETE CASCADE,
    turn_index INTEGER NOT NULL,
    
    pipeline_type VARCHAR(20) DEFAULT 'STREAMING',
    
    user_text TEXT,
    tutor_text TEXT,
    
    raw_payload_json JSONB,
    
    created_at TIMESTAMP NOT NULL DEFAULT timezone('utc', now()),
    
    CONSTRAINT unique_lesson_turn_index UNIQUE(lesson_id, turn_index)
);

CREATE INDEX idx_tutor_lesson_turns_lesson_id ON tutor_lesson_turns(lesson_id);
CREATE INDEX idx_tutor_lesson_turns_user_id ON tutor_lesson_turns(user_id);
CREATE INDEX idx_tutor_lesson_turns_pipeline_type ON tutor_lesson_turns(pipeline_type);
CREATE INDEX idx_tutor_lesson_turns_created_at ON tutor_lesson_turns(created_at DESC);

COMMENT ON TABLE tutor_lesson_turns IS 'Conversation turns with pipeline type tracking';
COMMENT ON COLUMN tutor_lesson_turns.turn_index IS 'Sequential index within lesson (0, 1, 2...)';
COMMENT ON COLUMN tutor_lesson_turns.pipeline_type IS 'Pipeline that generated this turn: STREAMING, ANALYSIS, INSIGHTS';
COMMENT ON COLUMN tutor_lesson_turns.raw_payload_json IS 'Debug info: STT confidence, latencies, etc.';

-- ============================================================
-- 3. tutor_brain_events: Events generated by Analysis pipeline
-- ============================================================

CREATE TABLE IF NOT EXISTS tutor_brain_events (
    id SERIAL PRIMARY KEY,
    lesson_id INTEGER NOT NULL REFERENCES tutor_lessons(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES user_accounts(id) ON DELETE CASCADE,
    turn_id INTEGER REFERENCES tutor_lesson_turns(id) ON DELETE SET NULL,
    
    pipeline_type VARCHAR(20) DEFAULT 'ANALYSIS',
    
    event_type VARCHAR(50) NOT NULL,
    
    event_payload_json JSONB NOT NULL,
    
    snapshot_student_knowledge_json JSONB,
    
    created_at TIMESTAMP NOT NULL DEFAULT timezone('utc', now())
);

CREATE INDEX idx_tutor_brain_events_lesson_id ON tutor_brain_events(lesson_id);
CREATE INDEX idx_tutor_brain_events_user_id ON tutor_brain_events(user_id);
CREATE INDEX idx_tutor_brain_events_event_type ON tutor_brain_events(event_type);
CREATE INDEX idx_tutor_brain_events_created_at ON tutor_brain_events(created_at DESC);
CREATE INDEX idx_tutor_brain_events_pipeline_type ON tutor_brain_events(pipeline_type);

COMMENT ON TABLE tutor_brain_events IS 'Events emitted by the Analysis/Brain pipeline';
COMMENT ON COLUMN tutor_brain_events.event_type IS 'Type of event: WEAK_WORD_ADDED, GRAMMAR_PATTERN_UPDATE, RULE_CREATED, etc.';
COMMENT ON COLUMN tutor_brain_events.event_payload_json IS 'Structured data about the event (see docs for schemas)';
COMMENT ON COLUMN tutor_brain_events.snapshot_student_knowledge_json IS 'Optional snapshot of student knowledge after this event';

-- ============================================================
-- 4. tutor_student_knowledge: Enhanced student knowledge tracking
-- ============================================================

CREATE TABLE IF NOT EXISTS tutor_student_knowledge (
    user_id INTEGER PRIMARY KEY REFERENCES user_accounts(id) ON DELETE CASCADE,
    
    level VARCHAR(10) DEFAULT 'A1',
    lesson_count INTEGER DEFAULT 0,
    first_lesson_completed BOOLEAN DEFAULT FALSE,
    
    vocabulary_json JSONB DEFAULT '{"weak": [], "strong": [], "neutral": []}'::jsonb,
    grammar_json JSONB DEFAULT '{"patterns": {}, "mistakes": {}}'::jsonb,
    topics_json JSONB DEFAULT '{"covered": [], "to_practice": []}'::jsonb,
    
    meta_json JSONB DEFAULT '{}'::jsonb,
    
    updated_at TIMESTAMP DEFAULT timezone('utc', now())
);

CREATE INDEX idx_tutor_student_knowledge_user_id ON tutor_student_knowledge(user_id);
CREATE INDEX idx_tutor_student_knowledge_level ON tutor_student_knowledge(level);
CREATE INDEX idx_tutor_student_knowledge_lesson_count ON tutor_student_knowledge(lesson_count);

COMMENT ON TABLE tutor_student_knowledge IS 'Current snapshot of student knowledge (vocabulary, grammar, topics)';
COMMENT ON COLUMN tutor_student_knowledge.vocabulary_json IS 'Structure: {"weak": [...], "strong": [...], "neutral": [...]}';
COMMENT ON COLUMN tutor_student_knowledge.grammar_json IS 'Structure: {"patterns": {...}, "mistakes": {...}}';
COMMENT ON COLUMN tutor_student_knowledge.topics_json IS 'Structure: {"covered": [...], "to_practice": [...]}';

-- ============================================================
-- 5. Trigger to auto-update updated_at timestamp
-- ============================================================

CREATE OR REPLACE FUNCTION update_tutor_student_knowledge_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc', now());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_tutor_student_knowledge_timestamp
BEFORE UPDATE ON tutor_student_knowledge
FOR EACH ROW
EXECUTE FUNCTION update_tutor_student_knowledge_timestamp();

-- ============================================================
-- 6. Sample brain event type enum (for documentation/validation)
-- ============================================================

COMMENT ON COLUMN tutor_brain_events.event_type IS 
'Valid event types:
- WEAK_WORD_ADDED: User struggled with a word
- WEAK_WORD_REMOVED: User mastered a previously weak word
- GRAMMAR_PATTERN_UPDATE: Grammar pattern usage detected
- RULE_CREATED: New tutor rule generated
- VOCABULARY_STRENGTH_CHANGE: Word moved between weak/neutral/strong
- PLACEMENT_TEST_COMPLETED: First lesson placement test done
- LESSON_SUMMARY_GENERATED: End-of-lesson summary created
';

-- ============================================================
-- End of migration
-- ============================================================
