# Onboarding Intro Session v1 (Знакомство с учеником)

## Зачем мы это делаем

У нас была одна большая, перегруженная система правил для голосового репетитора (универсальный greeting, выбор языкового режима, beginner-curriculum и т.п.). Для нового ученика это приводило к:
- тяжёлому, громоздкому system prompt;
- неочевидному поведению на первом уроке;
- отсутствию чёткой, один раз проходимой онбординг-сессии «знакомства».

Наша цель — вынести **первое знакомство** в отдельный, аккуратный сценарий, который запускается только один раз (на самом первом уроке), собирает базовые данные об ученике и сохраняет их в профиль. Все последующие уроки используют эти данные и не задают повторно одни и те же вопросы.

Ключевые принципы:
- Первый урок = **онбординг** (знакомство и настройки), а не сразу грамматика.
- Онбординг проходит один раз на аккаунт и помечается флагом `intro_completed`.
- Репетитор ведёт разговор по понятному дереву шагов (имя ученика, имя репетитора, ты/вы, стиль, цели и т.д.),
  а backend сохраняет результаты в профиль.
- Со второго урока репетитор сразу общается по-«человечески»: знает, как к ученику обращаться, как его звать и что он хочет.

## Какие данные мы собираем

Логически мы формируем объект `student_profile` (не как отдельную таблицу, а как содержимое `UserProfile.preferences["intro"]`), с полями:

- `student_name: str | null` — имя/форма, как ученику приятно, чтобы его называли.
- `tutor_name: str | null` — имя для репетитора («Mike», «Kate», «Пётр» и т.п.).
- `age: int | null` — возраст, только если ученик готов его назвать.
- `age_is_unknown: bool` — если не хочет говорить возраст.
- `addressing_mode: "ty" | "vy" | null` — на «ты» или на «вы» в русских репликах.
- `conversation_style: "formal" | "informal" | null` — формальный или более дружеский стиль.
- `humor_allowed: bool | null` — можно ли использовать шутки.
- `english_level_scale_1_10: int | null` — самооценка уровня по шкале 1–10.
- `goals: list[str]` — цели: travel, work, study, games, etc.
- `topics_interest: list[str]` — интересные темы: music, films, games, business, ...
- `native_language: str | null` — родной язык.
- `other_languages: list[str]` — другие языки, которыми владеет ученик.
- `correction_style: "often" | "on_request" | "soft" | null` — частота/жёсткость исправления ошибок.
- `intro_completed: bool` — флаг, что онбординг пройден.
- `intro_version: str | null` — версия онбординга (например, `"v1"`).
- `intro_completed_at: str | null` — ISO timestamp завершения онбординга.

Часть этих данных дублируется в основных полях `UserProfile`:
- `UserProfile.name` синхронизируется со `student_name`.
- `UserProfile.english_level` заполняется на основе `english_level_scale_1_10` (см. маппинг ниже).
- `UserProfile.goals` содержит простую текстовую версию `goals`.

## Где и как хранится информация

Мы **не добавляли новых таблиц** под онбординг, чтобы не усложнять схему. Вместо этого используем уже существующие модели:

- `UserProfile.preferences: str (JSON)` — здесь живут пользовательские настройки.
  - Внутри мы создаём/обновляем объект `intro`:
    ```json
    {
      "intro": {
        "student_name": "Вася",
        "tutor_name": "Mike",
        "age": 18,
        "age_is_unknown": false,
        "addressing_mode": "ty",
        "conversation_style": "informal",
        "humor_allowed": true,
        "english_level_scale_1_10": 8,
        "goals": ["travel", "work"],
        "topics_interest": ["music", "games"],
        "native_language": "Russian",
        "other_languages": ["Ukrainian"],
        "correction_style": "often",
        "intro_completed": true,
        "intro_version": "v1",
        "intro_completed_at": "2025-12-06T12:34:56Z"
      }
    }
    ```
- Основные поля `UserProfile` остаются источником истины для имени и уровня:
  - `name` — имя ученика (как его теперь надо звать).
  - `english_level` — CEFR-приближение (A0–C2).

Маппинг уровня 1–10 → CEFR реализован в `profile_service.map_scale_to_cefr` примерно так:

- 1 → `A0`
- 2 → `A1-`
- 3 → `A1/A2`
- 4 → `A2`
- 5 → `B1-`
- 6 → `B1/B2`
- 7 → `B2`
- 8 → `B2/C1`
- 9 → `C1`
- 10 → `C2`

## Протокол [PROFILE_UPDATE]

Чтобы не городить отдельные endpoint’ы на каждый мини-вопрос, мы сделали **текстовый протокол**, который понимает backend:

1. В системном промпте онбординга (см. `build_intro_system_prompt` в `tutor_service.py`) ИИ-инструкции требуют:
   - после каждого важного ответа выводить отдельную строку вида:
     ```
     [PROFILE_UPDATE] {"field": value, "field2": value2}
     ```
   - ключи — в `snake_case` (`student_name`, `tutor_name`, `addressing_mode` и т.п.).
   - JSON валидный, без комментариев и хвостовых запятых.
   - В конце онбординга — обязательный маркер:
     ```
     [PROFILE_UPDATE] {"intro_completed": true, "intro_version": "v1"}
     ```

2. На стороне backend в `profile_service.apply_intro_profile_updates` мы:
   - Сканыруем полный ответ ассистента построчно.
   - Для каждой строки, начинающейся с `[PROFILE_UPDATE]`, парсим JSON-объект.
   - На основании ключей обновляем:
     - `UserProfile.name`, `UserProfile.english_level`, `UserProfile.goals`;
     - и `preferences["intro"]`.
   - Ошибки JSON в одной строке **не ломают** сессию — мы просто пропускаем некорректный маркер, остальные обрабатываем.

Таким образом, диалог для пользователя выглядит естественно, а сохранение данных полностью скрыто в служебных маркерах.

## Когда запускается онбординг

В `tutor_service.should_run_intro_session` реализована логика определения, нужно ли включать режим онбординга для конкретного урока:

Онбординг запускается, если **все** условия выполняются:
- Есть валидный `UserProfile`.
- Есть текущий `LessonSession`.
- В `profile.preferences.intro.intro_completed` нет `true`.
- В базе **нет других** `LessonSession` для этого `user_account_id` (т.е. это первый урок данного аккаунта).

Это означает:
- **Новый ученик** (только что зарегистрировался, ни одного урока):
  - первый запуск голосового урока попадёт в сценарий онбординга;
  - по завершении запишется `intro_completed = true`.
- **Старые ученики** (уже есть сессии в `lesson_sessions`):
  - останутся на старом поведении, онбординг насильно не включается,
  - позже можно подумать про мягкую миграцию.

## Как это интегрировано в голосовой движок

### 1. Специальный системный промпт для онбординга

В `tutor_service.build_intro_system_prompt(user)` описан полный сценарий «знакомства»:
- приветствие и снятие страха;
- выбор имени репетитора;
- выбор имени ученика;
- возраст/отказ;
- ты/вы;
- стиль общения + юмор;
- цели и темы;
- языковой фон;
- стиль исправления ошибок;
- самооценка уровня;
- резюме и подтверждение;
- финальный `[PROFILE_UPDATE] {"intro_completed": true, ...}`.

### 2. Встраивание в `build_tutor_system_prompt`

Функция `build_tutor_system_prompt(session, user, lesson_session_id, is_resume)` теперь:
- сначала проверяет `should_run_intro_session(...)`;
- если это **первый урок без завершённого онбординга** — **сразу возвращает** `build_intro_system_prompt(user)` и не добавляет универсальный greeting, language-mode блок и beginner-curriculum;
- во всех остальных случаях работает как раньше (универсальный промпт + язык + beginner‑rules), но дополнительно учитывает `preferences.intro` (см. ниже).

### 3. Обновление профиля по ходу сессии

В `voice_ws.run_realtime_session`:
- после каждого финального ассистентского сообщения (ветка `response.output_item.done`):
  - текст сохраняется в `LessonTurn`;
  - вызывается `apply_intro_profile_updates(session, profile, transcript)`;
  - параллельно продолжаем старую логику по анализу маркеров `[LANGUAGE_MODE_*]` и т.п.

Таким образом, онбординг не требует дополнительных HTTP-запросов — всё проходит в одном realtime-канале.

## Как эти данные используются позже

После того, как `intro_completed = true`, все последующие уроки идут через обычный большой system prompt, но теперь он обогащён онбординг‑информацией.

В блоке **Student Context** (в `build_tutor_system_prompt`):
- Всегда есть:
  - `Name: {user.name}`;
  - `Level: {user.english_level}`.
- Если в `intro` есть данные, мы добавляем:
  - `TutorName (how the student calls you): {tutor_name}` + инструкция всегда говорить «Меня зовут {tutor_name}».
  - Инструкции по `addressing_mode` (строго на `ты` или строго на `вы` в русских репликах, без самовольного переключения).
  - Блок **Style Preferences (from onboarding)** — формальный/неформальный стиль, можно/нельзя шутить.
  - Блок целей и интересов — `Goals: ...`, `Topics they enjoy: ...`.
  - Блок **Error Correction Preference** — «часто», «по запросу» или «мягко».

Идея: с точки зрения модели, она теперь знает:
- как её зовут для этого ученика;
- как обращаться (ты/вы);
- насколько быть официальной и шутливой;
- какие цели и темы важны;
- как часто поправлять.

Соответственно, greetings и дальнейшие уроки становятся более персонализированными и консистентными.

## Как с этим работать админски и на уровне разработки

### Для админа / product owner

- **Просмотр профиля ученика**:
  - через существующие админ‑эндпоинты можно увидеть `UserProfile` и его `preferences`.
  - внутри `preferences.intro` хранится весь слепок онбординга.
- **Сброс онбординга** для конкретного пользователя (если нужно пройти знакомство заново):
  - вручную в базе/через админку удалить или изменить `preferences.intro.intro_completed` на `false`,
  - и (по желанию) удалить прошлые `LessonSession` для полного «обнуления» истории.

### Для разработчика

Основные файлы:
- `app/services/tutor_service.py`
  - `should_run_intro_session` — решает, включать ли онбординг для текущего урока.
  - `build_intro_system_prompt` — текст и логика онбординга.
  - `build_tutor_system_prompt` — встраивает онбординг и использует `intro`‑данные для персонализации.
- `app/services/profile_service.py`
  - `map_scale_to_cefr` — маппинг 1–10 → CEFR.
  - `apply_intro_profile_updates` — парсит `[PROFILE_UPDATE]` и обновляет профиль.
- `app/api/voice_ws.py`
  - `run_realtime_session` — создаёт `LessonSession`, определяет `intro_mode`,
    вызывает `build_tutor_system_prompt`, триггерит greeting и вызывает `apply_intro_profile_updates` на ассистентских репликах.

### Как менять сценарий в будущем

- **Изменить текст онбординга**:
  - редактировать `build_intro_system_prompt` (текстовые инструкции); структура протокола `[PROFILE_UPDATE]` при этом может не меняться.
- **Добавить новые поля**:
  1. Прописать их в описании `student_profile` в `build_intro_system_prompt`.
  2. Научить ассистента эмитить соответствующие ключи в `[PROFILE_UPDATE]`.
  3. Добавить обработку этих ключей в `apply_intro_profile_updates` (чтобы они попали в `intro` и, при необходимости, в основные поля `UserProfile`).
- **Сделать полноценную историю онбордингов**:
  - можно добавить отдельную таблицу (например, `student_intro_history`) и в момент `intro_completed = true` сохранять полный снапшот диалога и профиля.

## Дальнейшие шаги

- На базе этого онбординга можно отдельно спроектировать и реализовать «Первый учебный урок после знакомства», который:
  - опирается на уже собранные данные (уровень, цели, темы);
  - сразу стартует с подходящей активности (а не с общих вопросов);
  - подбирает материал под уровень и стиль.
- При необходимости можно добавить в админку отображение `intro`‑данных (как человекочитаемый блок «паспорт ученика»).

Этот документ фиксирует текущее видение онбординга **v1** и техническую реализацию. Новые версии (v2, v3, …) можно оформлять как отдельные разделы или новые файлы по мере эволюции сценария.